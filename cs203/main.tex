\documentclass[oneside]{book}
\usepackage[a4paper, margin=3cm]{geometry}
\usepackage{import}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{subcaption}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{cleveref}

\newcommand{\incfig}[1]{%
    \import{./figures/}{#1.pdf_tex}
}
\newcommand{\incfigsc}[2][1]{%
    \def\svgwidth{#1\columnwidth}
    \import{./figures/}{#2.pdf_tex}
}

\newcommand{\halfsubfig}[2][1]{
	\begin{subfigure}{0.45\linewidth}
		\centering
		\incfig{#1}
		\caption{#2}
	\end{subfigure}
}
\hypersetup{
    colorlinks,
    linkcolor={blue!80!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\title{CS203 - Digital Logic Design}
\author{Indian Institute of Technology Ropar}
\begin{document}
\maketitle
{
	\hypersetup{
		hidelinks
	}
	\tableofcontents
}
\renewcommand{\arraystretch}{1.5}%Sets the vertical margin

\chapter[Introduction]{Introduction to CS203}
Digital means discrete in nature(values as well as time). For example, our computer handle discrete data only, therefore are digital computers.\\
Analog means continuous in nature(values as well as time). For example, the atmospheric variables, our senses, etc are analog.

\section{Binary Classification}
Classification into \textbf{two} groups if called \textit{binary classification}. It is easy. For example, in computers, low voltage is classified as 0 and high voltage is classified as 1.\\
\begin{center}
	With N bits(binary digits), we can represent \(2^N\) states.
\end{center}
Some rounding off-
\begin{itemize}
	\item 10 bits - \(2^{10}\) states \(= 1024 \approx 10^3\)
	\item 20 bits - \(2^{20}\) states \(= 2^{10}\times 2^{10} \approx 10^6\)
	\item 30 bits - \(2^{30}\) states \(= 2^{10}\times 2^{10}\times 2^{10} \approx 10^9\) \hfill \(\sim\) Population of India
\end{itemize}

\section{Discretization}
The process of discretization of analog signal involves setting discrete levels in values as well as time. \Cref{discretization_plot} gives some idea.

\noindent We lose some information when discretization occurs. To minimize the loss, we can use \textbf{Nyquest Criteria}. Also, simply increasing the number of levels will reduce the error.

\begin{figure}[H]
	\centering
	\incfig{signal}
	\caption{Discretization of analog signal}
	\label{discretization_plot}
\end{figure}

\section{Analog vs Digial System}
Our world is analog but our devices are digital. \Cref{analog_digital_work_flow} shows working of analog and digital systems.
\\\\
\noindent \textbf{ADC} - Analog-to-digital converter\\
\noindent \textbf{DAC} - Digital-to-analog converter

\begin{figure}[H]
	\centering
	\halfsubfig[analog_system_flowchart]{Analog System}
	\halfsubfig[digital_system_flowchart]{Digital System}
	\caption{Analog and digial systems}
	\label{analog_digital_work_flow}
\end{figure}

\subsection{Advantages of Digital System}
\begin{itemize}
	\item \textbf{Precision}
	      \begin{itemize}
		      \item Small changes/error in signals does not affect the value. Even if errors occur in digital signal, it is easy to record the error and revert it.
		      \item Digital signals will produce same output for same input most of the time.
	      \end{itemize}
	\item \textbf{Programmability}
	      \begin{itemize}
		      \item Each analog system is created for specific use case. But digital systems have generic gates which allow reprogramming.
	      \end{itemize}
	\item \textbf{Maintainability}
	      \begin{itemize}
		      \item Digital signals are robust to change and can last longer(for years).
	      \end{itemize}
	\item \textbf{Design automation}
\end{itemize}

\subsection{Disadvantages of Digital System}
\begin{itemize}
	\item \textbf{Area/Cost}
	      \begin{itemize}
		      \item Cost of digital system is more than analog.
	      \end{itemize}
	\item \textbf{Power}
	\item \textbf{Performance}
	      \begin{itemize}
		      \item Digital signals are slower.
	      \end{itemize}
	\item \textbf{Bandwidth}
	\item \textbf{High Frequency Operations}
\end{itemize}

\subsection{Conclusion}
Most systems are going towards digital. But whenever we need very specific solution that required high bandwidth and frequency, analog systems are used. Radio recievers, transmitters, etc. are mostly analog.

\section{Factors pushing the growth story}
\begin{itemize}
	\item \textbf{Moore's law}
	      \begin{itemize}
		      \item The number of transistors on a unit area of circuit doubles every 18 months.
		      \item It is not a law but has been pretty accurate till now.
	      \end{itemize}
	\item \textbf{Technology}
	\item \textbf{Compute Requirements}
	\item \textbf{Design Automation}
\end{itemize}

\chapter{Binary Representation}
Historically, different bases(10, 12, 15, 16, 20) have been used.
There were two kinds of number system
\begin{itemize}
	\item \textbf{Positional}: Position of a number determines its value. For example, arabic, indic number systems.
	\item \textbf{Non-positional}: Value is largely decided by what symbol is used. For example, roman number system.
\end{itemize}
Finally, position based decimal system was accepted worldwide because it makes it easy to do calculations.

\section{Positional Number System}
Value of symbol depends on its position and radix/base.
\[
	N =
	(a_n a_{n-1} \ldots a_0)_R =
	\sum\limits_0^n a_i R^i
\]
The definition can be easily extended to fractions.
\[
	N =
	(a_n a_{n-1} \ldots a_0 a_{-1}\ldots a_{-m + 1} a_{-m})_R =
	\sum\limits_0^n a_i R^i
\]
Few examples
\begin{itemize}
	\item \(\displaystyle (101101)_2 = 1\times 2^{5} + 1\times 2^3 + 1\times 2^2 + 1\times 2^0 = 45\)
	\item \(\displaystyle (101.101)_2 = 1\times 2^{2} + 1\times 2^0 + 1\times 2^{-1} + 1\times 2^{-3} = 5.625\)
\end{itemize}

\subsubsection{Decimal to base-R conversion}
For converting the number \(N\) in base 10 to a number in base \(R\)
\begin{enumerate}
	\item Divide \(N\) by \(R\), the remainder is \(a_0\) and quotient is \(Q\)
	\item Set \(N\) as \(Q\) and repeat the above process to get subsequent digits \(a_1, a_2, \ldots\)
	\item Stop when \(N\) becomes zero
\end{enumerate}
\textbf{Example}: \((24)_{10} = (11000)_2\)
\begin{center}
	\begin{tabular}{|cccl|}
		\hline
		\(R\) & \(N\) & \(Q\) &             \\
		\hline
		2     & 24    & 12    & \(a_0 = 0\) \\
		2     & 12    & 6     & \(a_1 = 0\) \\
		2     & 6     & 3     & \(a_2 = 0\) \\
		2     & 3     & 1     & \(a_3 = 1\) \\
		2     & 1     & 0     & \(a_4 = 1\) \\
		2     & 0     &       &             \\
		\hline
	\end{tabular}
\end{center}

\noindent For converting fractional part \(F\) to base R
\begin{enumerate}
	\item Multiply \(F\) with \(R\), the non-fractional part is \(a_{-1}\) and fractional part is \(F^\prime\)
	\item Set \(F\) as \(F^\prime\) and repeat the above process to get subsequent digits \(a_{-2}, a_{-3}, \ldots\)
	\item Stop when \(F\) becomes zero
\end{enumerate}
\textbf{Example}: \((0.7)_{10} = (0.10110011001100110011\cdots)_2\)
\begin{center}
	\begin{tabular}{|cccl|}
		\hline
		\(R\)      & \(F\)      & \(F^\prime\) &                \\
		\hline
		2          & 0.7        & 0.4          & \(a_{-1} = 1\) \\
		2          & 0.4        & 0.8          & \(a_{-2} = 0\) \\
		2          & 0.8        & 0.6          & \(a_{-3} = 1\) \\
		2          & 0.6        & 0.2          & \(a_{-4} = 1\) \\
		2          & 0.2        & 0.4          & \(a_{-5} = 0\) \\
		2          & 0.4        & 0.8          & \(a_{-6} = 0\) \\
		2          & 0.8        & 0.6          & \(a_{-7} = 1\) \\
		2          & 0.6        & 0.2          & \(a_{-8} = 1\) \\
		\(\vdots\) & \(\vdots\) & \(\vdots\)   &                \\
		\hline
	\end{tabular}
\end{center}


\section{Hexadecimal Number System}
Hexadecimal system requires 16 symbols which are \(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\). Hex numbers are generally prefixed by \texttt{0x}.

\subsubsection{Conversion from binary to hex}
To convert a binary number to hex, group the binary number into groups of four(nibbles) from right to left. Then, convert each nibble to hex using a lookup table or simple conversion.
\[
	(\texttt{10011110001})_2 \longrightarrow \texttt{100\ 1111\ 0001} \longrightarrow \texttt{0x4F1}
\]

\subsubsection{Conversion from hex to binary}
To convert a hex to binary number, convert each digit to binary and make its length 4 by adding zeros as prefix. Now concatenate these so formed nibbles.
\[
	\texttt{0xBAD} \longrightarrow \texttt{1011\ 1010\ 1101} \longrightarrow (\texttt{101110101101})_2
\]

\section{Negative Numbers}
\subsection{Sign Magnitude Negative Numbers}
We can set one bit to represent the sign. Generally, we choose the most-significant bit as the sign bit.
\\\\
\textbf{Example}
\begin{align*}
	(1010\ 0011)_2 & = (-35)_{10} \\
	(0111\ 1111)_2 & = (127)_{10}
\end{align*}

\noindent So the range of \(N\)-bit number is \(-(2^{N-1} - 1)\) to \((2^{N-1} - 1\)).
\\
\noindent Also, such representation has two zeros - positive and negative.
\\
\subsubsection{Addition and subtraction}
\noindent Addition and subtraction becomes difficult.
\begin{itemize}
	\item We have to look at the signs and then choose what operation will be performed.
	\item Two zeros create confusion.
	\item Either operation may result in addition or subtraction
	\item Complex hardware implementation
	      \begin{itemize}
		      \item Requires both adder and subtractor
		      \item Requires controller that determine which hardware to use
		      \item Separate handling of sign
	      \end{itemize}
\end{itemize}

\subsection{1's Complement}
For obtaining \(-u\) flip all the bits of \(u\). Here also, \(N^{th}\) bit represents sign and \(N-1\) bits represent magnitude.
\\\\ \noindent\textbf{Example}
\begin{align*}
	(+13)_{10} & = (0000\ 1101)_2 & (+69)_{10} & = (0010\ 0101)_2 \\
	(-13)_{10} & = (1111\ 0010)_2 & (-69)_{10} & = (1101\ 1010)_2
\end{align*}
\noindent So the range of \(N\)-bit number is \(-(2^{N-1} - 1)\) to \((2^{N-1} - 1\)).
\subsubsection{Mathematical representation}
We know \(2^{N} - 1 = 111\ldots1\)
\[
	\therefore -u =\ \sim|u| = 2^N - 1 - |u|
\]
\subsubsection{Addtion and subtraction}
\noindent Addition and subtraction is difficult.
\begin{itemize}
	\item In \textit{end-around carry} condition, the wrapped bit must be added to the right-most bit.
	\item In \textit{end-around borrow} condition, the wrapped bit must be subtracted from the right-most bit.
	\item There are two representation of zeros.
\end{itemize}

\subsection{Bias Representation}
Let \(F(u)\) be the value of binary representation of \(u\). In bias represent
\[
	F(u) = u + bias
\]
\noindent\textbf{Example} (with bias = 127)
\begin{align*}
	(1)_{10}    & = (1000\ 0000)_2 \\
	(-127)_{10} & = (0000\ 0000)_2 \\
	(128)_{10}  & = (1111\ 1111)_2
\end{align*}

\subsubsection{Problems}
\begin{itemize}
	\item Bias should be adjusted while adding two numbers
	      \[
		      F(u + v) = F(u) + F(v) - bias
	      \]
	\item Bias should be standardized
\end{itemize}

\subsection{2's Complement}
When \(u >= 0\)
\[
	F(u) = |u|
\]
When \(u < 0\)
\[
	F(u) = 2^N - |u| =\ \sim|u| + 1
\]
\subsubsection{Properties}
\begin{itemize}
	\item Single zero
	\item Most-significant bit represents sign(except in case of zero)
	\item \(F(-u) = 2^N - F(u)\)
	\item Range is from \(-2^{N-1}\) to \((2^{N-1} - 1)\)
\end{itemize}

\subsubsection{Arithmetic}
\begin{itemize}
	\item Addition
	      \[
		      F(u+v) = F(u) + F(v)
	      \]
	\item Subtraction
	      \[
		      F(u-v) = F(u) + F(-v)
	      \]
	\item Multiplication (assume no overflow)
	      \[
		      F(u\times v) = F(u)\times F(v)
	      \]
\end{itemize}
\subsubsection{Overflow and Underflow}
\begin{itemize}
	\item If sign of both operands are same and result if of opposite sign or result is 0, overflow/underflow has occured.
	\item If sign of both operands are different, overflow cannot occur.
\end{itemize}

\subsubsection{Converting N-bit number to M-bit number}
To convert to \(N\)-bit number to \(M\)-bit number(\(M\geq N\)) keep adding the sign bit as prefix until the size becomes \(M\).
\\
Example (Converting 4-bit number to 8-bit number)
\begin{align*}
	(3)_{10} = (\textcolor{red}{1}101)_2 = (\textcolor{red}{1111\ 1}101)_2 \\
	(5)_{10} = (\textcolor{red}{0}101)_2 = (\textcolor{red}{0000\ 0}101)_2
\end{align*}

\subsection{Number Circle}
An efficient way to see different representations in action.
\begin{itemize}
	\item To add \(x\) to \(u\), move \(x\) steps in clockwise direction from \(u\).
	\item To subtract \(x\) from \(u\), move \(x\) steps in counter-clockwise direction from \(u\).
	\item Crossing dotted lines will result in underflow/overflow.
\end{itemize}
Visit \url{https://thesis.laszlokorte.de/demo/number-circle.html} to experiment.

\section{Representing Decimal Numbers and Characters}
We have to find a one-to-one mapping between binary combination and corresponding decimal value. \textit{Is there any option better than positional number system?}.
\subsection{Binary Coded Decimal (BCD) Number System}
In BCD, each decimal digit is mapped to a nibble of its value. These nibbles are concatenated to get the binary representation.
\\\\
\noindent \(8421\) BCD number are numbers where the bits of nibbles have weights \(8\), \(4\), \(2\) and \(1\). It is the \textit{default} BCD representation.
\textbf{Example}
\[
	(5682)_{10} \longrightarrow (0101\ 01110\ 1000\ 0010)_2
\]
\subsubsection{Advantages}
\begin{itemize}
	\item No complex procedure for conversion from decimal representation required.
	\item BCD numbers are intuitive i.e. one can look at the binary number and grasp the value quickly.
\end{itemize}
Initial computer (e.g. IBM System/360) used BCD numbers.
\subsubsection{Disadvantages}
\begin{itemize}
	\item During arithemtic, we have to take care that value of no nibble exceeds 9.\\
	      In case, when value exceeds 9 (i.e. the value is not a valid BCD number), then add \((0110)_2\) to the result.\\
	      \textbf{Why did we add 6?}\\
	      \cite{bcd_addition_overflow} Because there are 6 invalid states in BCD numbers. To skip those states, we added 6.
\end{itemize}

\subsection{Excess 3 Code}
It is another BCD representation where value of each digit is 3 more in binary than in decimal.
\\\textbf{Note:} Be careful while adding numbers in \textit{Excess 3 code}.
\[
	\mathrm{Excess3Add}(u, v) = \mathrm{Excess3}(u) + \mathrm{Excess3}(v) - (0011)_2
\]
\begin{table}[ht]
	\centering
	\begin{tabular}{|cc|}
		\hline
		Decimal    & Excess 3 Code \\
		\hline
		0          & 0011          \\
		1          & 0100          \\
		2          & 0101          \\
		3          & 0110          \\
		\(\vdots\) & \(\vdots\)    \\
		8          & 1011          \\
		9          & 1100          \\
		\hline
	\end{tabular}
	\caption{Excess 3 code mapping}
\end{table}
\subsubsection{Advantages}
\begin{itemize}
	\item \textbf{Self Complementing}\\
	      9's complement can be obtained by inverting all the bits.
	      \[
		      \mathrm{Excess3}(9 - x) =\ \sim \mathrm{Excess3}(x)
	      \]
	      It helps in doing subtration by addition.\\
	      Consider the addition of two digits $d_1$ and $d_2$ (digits are represented in excess 3 code).
	      \[
		      \mathrm{Excess3Subtraction}(d_2, d_1) =\ \sim\mathrm{Excess3Add}(\sim d_2, d_1)
	      \]
\end{itemize}

\subsection{Two-out-of-five Code}
It is another BCD representation where each decimal digit is mapped to a group of 5 bits. Each digit's binary representation contains \textbf{exactly} two 1s.
\begin{table}[ht]
	\centering
	\begin{tabular}{|cc|}
		\hline
		Decimal & Two-out-of-five Code \\
		\hline
		0       & 00011                \\
		1       & 00101                \\
		2       & 00110                \\
		3       & 01001                \\
		4       & 01010                \\
		5       & 01100                \\
		6       & 10001                \\
		7       & 10010                \\
		8       & 10100                \\
		9       & 11000                \\
		\hline
	\end{tabular}
	\caption{Two-out-of-five code mapping}
\end{table}
\subsubsection{Advantages}
\begin{itemize}
	\item \textbf{Error Resilient}\\
	      If any or several bits flip, there is a high chance that it will not contain 2 ones. In that case, we can know that the value is incorrect and we can redo the computation.
\end{itemize}

\subsection{Gray Code}
It is another BCD representation. It is a low power code because the trasititions between adjacent numbers is minimum.
\begin{table}[ht]
	\centering
	\begin{tabular}{|cc|}
		\hline
		Decimal & Gray Code \\
		\hline
		0       & 0000      \\
		1       & 0001      \\
		2       & 0011      \\
		3       & 0010      \\
		4       & 0110      \\
		5       & 1110      \\
		6       & 1010      \\
		7       & 1011      \\
		8       & 1001      \\
		9       & 1000      \\
		\hline
	\end{tabular}
	\caption{Gray code mapping}
\end{table}
\subsubsection{Advantages}
\begin{itemize}
	\item \textbf{Low Power Consumption}\\
	      Since the transition between adjacent numbers is minimum, power consumption is minimized.
\end{itemize}
\subsubsection{Gray Code Sequence}
To generate Gray code sequence, do the following\cite{gray_code_generation}:
\begin{enumerate}
	\item Commence with the simplest Gray code possible; that is, for a single bit.
	\item Create a mirror image of the existing Gray code below the original values.
	      \label{gray_code_step_2}
	\item Prefix the original values with 0s and the mirrored values with 1s.
	      \label{gray_code_step_3}
	\item Repeat step \ref{gray_code_step_2} and \ref{gray_code_step_3} until the desired width is achieved.
\end{enumerate}
\begin{figure}[H]
	\centering
	\incfig{gray_code_generation}
	\caption{Gray code generation upto 3 bits}
	\label{gray_code_generation}
\end{figure}

\section{Representing Characters}
\begin{itemize}
	\item \textbf{ASCII}\\
	      Using 8-bit number for each commonly used character
	\item \textbf{UTF-8}
	      \begin{itemize}
		      \item Compatible with ASCII
		      \item Uses 1 to 6 bytes
	      \end{itemize}
	\item \textbf{UTF-16}
\end{itemize}

\section{Real Numbers}
How would we represent a decimal point in binary?
\subsection{Fixed Point Numbers}
In this kind of numbers, we would fix some bits for only the fractional part.
\\\\
\noindent\textbf{Example} (Assuming 4 decimal digits can be represented and decimal point is after 2 digits)
\begin{align*}
	2300 & \ \mathrm{would\ represent}\ 23.00 \\
	123  & \ \mathrm{would\ represent}\ 1.23  \\
	1    & \ \mathrm{would\ represent}\ 0.01  \\
	100  & \ \mathrm{would\ represent}\ 1.00
\end{align*}

\subsection{Floating Point Numbers}
To represent very large and very small number, we use scientific notation.
\begin{align*}
	\mathrm{In\ decimal:}\  & 129 = 1.29 \times 10^2        \\
	\mathrm{In\ binary:}\   & 1000001 = 1.000001 \times 2^6
\end{align*}
Such numbers have 3 parts:
\begin{enumerate}
	\item \textbf{Significand}($s$): The digit and sign before point\\
	      Can only be $+1$ or $-1$
	\item \textbf{Mantissa}($m$): The fractional part of number\\
	      Can only be positive
	\item \textbf{Exponent}($e$): The power of $2$\\
	      Can be positive or negative
\end{enumerate}

\subsubsection{Typical representation}
\begin{itemize}
	\item 1 bit is reserved for significand
	\item Next few bits for exponent
	\item Remaining bits for mantissa
\end{itemize}

\subsection{IEEE 754 Single Precision Floating Point Numbers}
32-bit number (single precision)
\begin{itemize}
	\item 1 bit is reserved for significand ($s$)
	\item 8 bits for exponent ($e$)
	      \begin{itemize}
		      \item Bias representation (with $bias=127$)\\
		            Bias method is sufficient because only addition is need in exponent
		      \item $(0000 0000)_2$ and $(1111 1111)_2$ are reserved for special purpose
	      \end{itemize}
	\item 23 bits for mantissa ($m$)
	\item \(N = (-1)^s \times (1.m)\times 2^e\)
\end{itemize}
\cite{ieee_745_floating_point_number} Visit \url{https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/} for more information.\\
\cite{ieee_745_floating_point_number_converter} \url{https://www.h-schmidt.net/FloatConverter/IEEE754.html} is an online converter.
\\\\\noindent\textbf{Example}\\
\begin{table}[ht]
	\centering
	\begin{tabular}{|ll|}
		\hline
		\multicolumn{2}{|c|}{\textbf{Converting 24.25 to IEEE 754 floating point number}}                  \\
		\hline
		Decimal number        & $24.25 = 16 + 8 + 0.25$                                                    \\
		Binary number         & 11000.01                                                                   \\
		Scientific form       & $1.100001\times 2^4$                                                       \\
		\hline
		Significand           & 0                                                                          \\
		Mantissa              & 100 0010 0000 0000 0000 0000                                               \\
		Exponent              & $(127 + 4)_{10} = (1000\ 0011)_2$                                          \\
		\hline
		Floating Point Number & \textcolor{red}{0}\textcolor{blue}{100 0001 1}100 0010 0000 0000 0000 0000 \\
		In Hex                & 0x41920000                                                                 \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[ht]
	\centering
	\begin{tabular}{|ll|}
		\hline
		\multicolumn{2}{|c|}{\textbf{Converting -0.625 to IEEE 754 floating point number}}                 \\
		\hline
		Decimal number        & $-0.625 = -1\times(0.5 + 0.125)$                                           \\
		Binary number         & -0.101                                                                     \\
		Scientific form       & $-1.01\times 2^{-1}$                                                       \\
		\hline
		Significand           & 1                                                                          \\
		Mantissa              & 010 0000 0000 0000 0000 0000                                               \\
		Exponent              & $(127 + 0)_{10} = (1111\ 1111)_2$                                          \\
		\hline
		Floating Point Number & \textcolor{red}{1}\textcolor{blue}{111 1111 1}010 0000 0000 0000 0000 0000 \\
		In Hex                & 0xFFA00000                                                                 \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[ht]
	\centering
	\begin{tabular}{|ll|}
		\hline
		\multicolumn{2}{|c|}{\textbf{Converting 0xC2630000 to decimal}}                                    \\
		\hline
		In Hex                & 0xC2630000                                                                 \\
		Floating Point Number & \textcolor{red}{1}\textcolor{blue}{100 0010 0}110 0011 0000 0000 0000 0000 \\
		\hline
		Significand           & 1                                                                          \\
		Exponent              & $(100\ 0010\ 0)_2 = (127 + 5)_{10}$                                        \\
		Mantissa              & 110 0011 0000 0000 0000 0000                                               \\
		\hline
		Scientific form       & $1.1100011\times 2^{5}$                                                    \\
		Binary number         & 111000.11                                                                  \\
		Decimal number        & $56.75$                                                                    \\
		\hline
	\end{tabular}
\end{table}

\subsection{Denormal/subnormal Numbers}
\label{denormal_number_section}
In a normal floating-point value, there are no leading zeros in the significand; rather, leading zeros are removed by adjusting the exponent (for example, the number 0.0123 would be written as \(1.23 \times 10^{-2}\)). Denormal numbers are numbers where this representation would result in an exponent that is below the smallest representable exponent (the exponent usually having a limited range). Such numbers are represented using leading zeros in the significand. \cite{ieee_745_denormal}

\subsection{Special Values}
IEEE reserves exponent field values of all 0s and all 1s to denote special values in the floating-point scheme. \cite{ieee_745_special_values}
\subsubsection{Denormalized}
If the exponent is all 0s, then the value is a \textit{denormalized number} (\cref{denormal_number_section}), which now has an assumed leading 0 before the binary point. Thus,
\[
	N = (-1)^s \times 0.m \times 2^{-126}
\]
As denormalized numbers get smaller, they lose precision as left bits of the mantissa become zeros.

\subsubsection{Zero}
Zero is a denormalized number, with all bits in exponent and mantissa set to 0. If significand is 1, it represents -0, else +0. Also,
\[
	+0 = -0
\]

\subsubsection{Infinity}
When exponent is all 1s and mantissa is all 0s, it represents \textit{infinity}. If significand is 1, it represents \(-\infty\), else \(+\infty\).

\subsubsection{Not a Number(NaN)}
The value \textit{NaN} is used to represent a value that does not represent a real number. Nan's are represented by a bit pattern with exponent of all 1s and a non-zero mantissa. There are two types on NaN's
\begin{enumerate}
	\item \textbf{Quiet NaN (QNan)}\\
	      A QNaN is a NaN with the most-significant mantissa bit set to 1. It represents \textit{indeterminate operations}.
	\item \textbf{Signalling NaN (SNan)}\\
	      A SNaN is a NaN with the most-significant mantissa bit set to 0. It represents \textit{invalid operations}.

\end{enumerate}

\subsection{IEEE 754 Half Precision Floating Point Numbers}
16-bit number (half precision)
\begin{itemize}
	\item 1 bit is reserved for significand ($s$)
	\item 5 bits for exponent ($e$)
	      \begin{itemize}
		      \item Bias representation (with $bias=15$)
		      \item $(0 0000)_2$ and $(1 1111)_2$ are reserved for special purpose
	      \end{itemize}
	\item 10 bits for mantissa ($m$)
\end{itemize}
\subsection{IEEE 754 Double Precision Floating Point Numbers}
64-bit number (double precision)
\begin{itemize}
	\item 1 bit is reserved for significand ($s$)
	\item 11 bits for exponent ($e$)
	      \begin{itemize}
		      \item Bias representation (with $bias=1023$)
		      \item $(000 0000 0000)_2$ and $(111 1111 1111)_2$ are reserved for special purpose
	      \end{itemize}
	\item 52 bits for mantissa ($m$)
\end{itemize}

\subsection{Issues with Floating Point Numbers}
\begin{itemize}
	\item \textbf{Quantization Issues}
	      \begin{itemize}
		      \item Different rounding can lead to different results
		      \item Different formats have different precision
		      \item Accumulation of errors
		      \item Non-terminating numbers cannot be represented
	      \end{itemize}
	\item \textbf{Hardware/Computational Costs}
\end{itemize}

\chapter{Boolean Algebra}
Boolean algebra is algebra on boolean values - \textit{true} and \textit{false}.
These boolean values can be represented by bits - 0 for \textit{false} and 1 for \textit{true}.


\noindent A \textit{boolean function} is a function that takes boolean inputs, performs only boolean operations and returns a boolean output.
A \textit{truth table} is a table listing outcomes of a function for every combination of input variables.
\section{Basic Operations}
\label{basic_boolean_operations_section}
There are three basic operations in boolean algebra.
\begin{enumerate}
	\item \textbf{AND}\\
	      \(A\) {AND} \(B\) is \textit{true} iff both \(A\) and \(B\) are \textit{true}. This is also called \textbf{product} in boolean algebra.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $A\cdot B$ \\
			      \hline
			      0   & 0   & 0          \\
			      0   & 1   & 0          \\
			      1   & 0   & 0          \\
			      1   & 1   & 1          \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for AND}
		      \label{truth_table_for_and}
	      \end{table}
	\item \textbf{OR}\\
	      \(A\) {OR} \(B\) is \textit{true} iff at least one of \(A\) and \(B\) is \textit{true}. This is also called \textbf{sum} in boolean algebra.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $A\cdot B$ \\
			      \hline
			      0   & 0   & 0          \\
			      0   & 1   & 1          \\
			      1   & 0   & 1          \\
			      1   & 1   & 1          \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for OR}
		      \label{truth_table_for_or}
	      \end{table}
	\item \textbf{OR}\\
	      NOT \(A\) is \textit{true} iff \(A\) is \textit{false}.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|c|c|}
			      \hline
			      $A$ & $A^\prime$ \\
			      \hline
			      0   & 1          \\
			      1   & 0          \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for NOT}
		      \label{truth_table_for_not}
	      \end{table}
\end{enumerate}

\section{Basic Theorems}
\begin{itemize}
	\item \textbf{Operation with 0}\\
	      \begin{align*}
		      X + 0    & = X \\
		      X\cdot 0 & = 0
	      \end{align*}
	\item \textbf{Operation with 1}\\
	      \begin{align*}
		      X + 1    & = 1 \\
		      X\cdot 1 & = X
	      \end{align*}
	\item \textbf{Idempotent Law}\\
	      \begin{align*}
		      X + X    & = X \\
		      X\cdot X & = X
	      \end{align*}
	\item \textbf{Involution Law}\\
	      \begin{align*}
		      (X^\prime)^\prime & = X
	      \end{align*}
	\item \textbf{Law of Complementarily}\\
	      \begin{align*}
		      X + X^\prime    & = 1 \\
		      X\cdot X^\prime & = 0
	      \end{align*}
	\item \textbf{Commutative Law}\\
	      \begin{align*}
		      X + Y    & = Y + X     \\
		      X\cdot Y & = Y \cdot X \\
	      \end{align*}
	\item \textbf{Associative Law}\\
	      \begin{align*}
		      (X + Y) + Z        = X + (Y + Z)          = X + Y + Z \\
		      (X\cdot Y)\cdot Z  = X \cdot (Y \cdot Z)  = X\cdot Y\cdot Z
	      \end{align*}
	\item \textbf{Distributive Law}\\
	      \begin{align*}
		      X \cdot( Y + Z) & = X\cdot Y + X\cdot Z   \\
		      X+(Y\cdot Z)    & = (X + Y) \cdot (X + Z) \\
	      \end{align*}
	\item \textbf{DeMorgans's Law}\\
	      \begin{align*}
		      ( X + Y)^\prime     & = X^\prime\cdot Y^\prime \\
		      ( X \cdot Y)^\prime & = X^\prime + Y^\prime    \\
	      \end{align*}
\end{itemize}

\section{Duality Principle}
0 is identity for OR. 1 is identity for AND.
\begin{center}
	Laws of boolean algebra remain same if operators and identity elements are interchanged.
\end{center}
In simple words, if in a boolean equation, all 0s and 1s are exchanged and all OR operators and all AND operators are exchanged with each other, the boolean equation continues to hold its validity.

\section{Simplification Theorems}
\label{simplification_theorems_section}
\begin{enumerate}
	\item \textbf{Uniting}\\
	      \begin{align*}
		      X\cdot Y + X\cdot Y^\prime  & = X \\
		      (X + Y)\cdot (X + Y^\prime) & = X
	      \end{align*}
	      \label{uniting_theorem}
	\item \textbf{Absorption}\\
	      \begin{align*}
		      X+ X\cdot Y    & = X \\
		      X\cdot (X + Y) & = X
	      \end{align*}
	\item \textbf{Elimination}\\
	      \begin{align*}
		      X+ (X^\prime\cdot Y)  & = X + Y    \\
		      X\cdot (X^\prime + Y) & = X\cdot Y
	      \end{align*}
	\item \textbf{Consensus}\\
	      \begin{align*}
		      X\cdot Y+ X^\prime\cdot Z + Y\cdot Z     & = X\cdot Y + X^\prime \cdot Z  \\
		      (X + Y)\cdot (X^\prime + Z)\cdot (Y + Z) & =( X + Y )\cdot (X^\prime + Z)
	      \end{align*}
\end{enumerate}

\section{Standard Boolean Expressions}
$A, A^\prime, B, $ etc. are called \textit{literals} and $AB, BC^\prime A, $ etc. are called \textit{terms}.
\begin{enumerate}
	\item \textbf{Sum of products (SOP)}\\
	      \textsc{Examples}:
	      \begin{itemize}
		      \item $AB^\prime + BCD + A^\prime C$
		      \item $A^\prime + B^\prime + C^\prime + DE$
	      \end{itemize}
	\item \textbf{Products of sum (POS)}\\
	      \textsc{Examples}:
	      \begin{itemize}
		      \item $(A + B^\prime)(B + C + D)(A^\prime + C)$
		      \item $A^\prime B C^\prime (D + E)$
	      \end{itemize}
\end{enumerate}

\section{Minimizing Boolean Function}
To reduce cost and improve performance, boolean functions are minimized. We will try to develope a systematic and procedural approach.
\subsection{Canonical/Standard Forms}
There can be several equivalent boolean expressions. Therefore, we need to have a standard form.
\subsubsection{Minterm}
We get 4 boolean terms by combining two variables $x$ and $y$ with logical $AND$ operation. These boolean product terms are called \textit{minterms} or \textit{standard product terms}.\cite{minterm_maxterm_definition}
\subsubsection{Minterm}
We get 4 boolean terms by combining two variables $x$ and $y$ with logical $OR$ operation. These boolean product terms are called \textit{maxterms} or \textit{standard sum terms}.\cite{minterm_maxterm_definition}
\begin{table}[ht]
	\centering
	\begin{tabular}{|r|cc|c|c|}
		\hline
		$\mathbf{i}$ & $\mathbf{x}$ & $\mathbf{y}$ & \textbf{Minterm} ($m_i$) & \textbf{Maxterm} ($M_i$) \\
		\hline
		0            & 0            & 0            & $x^\prime y^\prime$      & $x + y$                  \\
		1            & 0            & 1            & $x^\prime y$             & $x + y^\prime$           \\
		2            & 1            & 0            & $x y^\prime$             & $x^\prime + y$           \\
		3            & 1            & 1            & $x y$                    & $x^\prime + y^\prime$    \\
		\hline
	\end{tabular}
	\caption{Minterms and maxterms for two variables $x$ and $y$}
\end{table}
There are 2 cannoical forms
\begin{enumerate}
	\item \textbf{Cannonical SoP - Sum of product}
	      Each term should contain all the variables - either in normal or complemented form i.e. each term in SoP is a minterm. So a function in SoP form can be written as
	      \[
		      F = m_{i_1} + m_{i_2} + \cdots  = \sum m(i_1, i_2, \ldots)
	      \]
	\item \textbf{Cannonical PoS - Product of sum}
	      Each sum term should contain all the variables - either in normal or complemented form i.e. each term in PoS is a maxterm. So a function in PoS form can be written as
	      \[
		      F = M_{i_1} \cdot M_{i_2} \cdot \cdots  = \prod M(i_1, i_2, \ldots)
	      \]
\end{enumerate}
\subsubsection{Properties}
\begin{itemize}
	\item Cannonical PoS and SoP forms are complementary.
	      \[
		      F = \prod M(0, 1, 2, 4, 6) = \sum m(3, 5, 7)
	      \]
	\item DeMorgen's law
	      \begin{align*}
		      F = \sum m(3, 5, 7)         & = a^\prime bc + ab^\prime c + abc                                                    \\
		      F^\prime = \prod M(3, 5, 7) & = (a + b^\prime + c^\prime)(a^\prime + b + c^\prime)(a^\prime + b^\prime + c^\prime)
	      \end{align*}
\end{itemize}
The expressions in cannonical form can be simplified using \textit{uniting theorem}(theorem \ref{uniting_theorem} in \cref{simplification_theorems_section}).

\subsection{Incompletely Specified Functions}
An \textit{incompletely specified function} is a boolean function that only define values for a subset of its inputs. The undefined outputs are called \textbf{don't care}.\cite{incompletely_specified_function}
\\\\
\textbf{Example:}
\[
	F(a, b) = \sum m(1) + \sum d(0, 3)
\]
\begin{table}[ht]
	\centering
	\begin{tabular}{|cc|c|}
		\hline
		$\mathbf{a}$ & $\mathbf{b}$ & $\mathbf{F(a, b)}$ \\
		\hline
		0            & 0            & \textcolor{red}{?} \\
		0            & 1            & 1                  \\
		1            & 0            & 0                  \\
		1            & 1            & \textcolor{red}{?} \\
		\hline
	\end{tabular}
\end{table}

\subsection{Karnaugh Map}
Karnaugh maps are graphical method of minimizing boolean expressions.\\
Visit \url{https://en.wikipedia.org/wiki/Karnaugh_map} to learn about Karnaugh maps. \cite{karnaugh_map_wiki}\\\\
\noindent\url{https://www.charlie-coleman.com/experiments/kmap/} is a popular solver.

\subsection{Quine-McCluskey Method}
Karnaugh map becomes very difficult when number of variables increase. Here, Quine-McCluskey method comes to rescue.\\
Visit \url{https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm} to learn about Quine-McCluskey methods. \cite{quine_mccluskey_algorithm_wiki}\\\\
\noindent\url{http://quinemccluskey.com/} is a popular solver. I think it failed for \(f(a,b,c) = \sum m(0,1,2,5,6,7)\).\\\\
\noindent\url{https://www.mathematik.uni-marburg.de/~thormae/lectures/ti1/code/qmc/} is a good solver.

\section{Logic Gates}
We have already discussed 3 gates in \cref{basic_boolean_operations_section}. We will see some more gates in this section.
\begin{enumerate}
	\item \textbf{XOR}\\
	      XOR of n-inputs is $1$ if number of inputs having value $1$ are odd.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $A\oplus B$ \\
			      \hline
			      0   & 0   & 0           \\
			      0   & 1   & 1           \\
			      1   & 0   & 1           \\
			      1   & 1   & 0           \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for XOR}
		      \label{truth_table_for_xor}
	      \end{table}
	\item \textbf{XNOR}\\
	      XNOR of n-inputs is $1$ if number of inputs having value $1$ are even. It is the inversion of XOR.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $A\odot B$ \\
			      \hline
			      0   & 0   & 1          \\
			      0   & 1   & 0          \\
			      1   & 0   & 0          \\
			      1   & 1   & 1          \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for XNOR}
		      \label{truth_table_for_xnor}
	      \end{table}
	\item \textbf{NAND}\\
	      NAND is AND followed by NOT.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $(A\cdot B)^\prime$ \\
			      \hline
			      0   & 0   & 1                   \\
			      0   & 1   & 1                   \\
			      1   & 0   & 1                   \\
			      1   & 1   & 0                   \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for NAND}
		      \label{truth_table_for_nand}
	      \end{table}
	\item \textbf{NOR}\\
	      NOR is OR followed by NOT.
	      \begin{table}[ht]
		      \centering
		      \begin{tabular}{|cc|c|}
			      \hline
			      $A$ & $B$ & $(A+ B)^\prime$ \\
			      \hline
			      0   & 0   & 1               \\
			      0   & 1   & 0               \\
			      1   & 0   & 0               \\
			      1   & 1   & 0               \\
			      \hline
		      \end{tabular}
		      \caption{Truth table for NOR}
		      \label{truth_table_for_nor}
	      \end{table}
\end{enumerate}

\noindent NAND and NOR gates are universal gates. We can make all other gates using NAND or NOR gates only.

\section{Cost}
Cost is determined by \textit{area} and \textit{delay}.
\subsection{Area}
The amount of silicon required is a way to consider area. We can also see area as the number of gates required.

\subsection{Delay}
Delay is the amount of time required for processing(time-different between output and input). If \textit{fan-in}(\(F_{in}\)) is the number of input gates and \textit{fan-out}(\(F_{out}\)) is the number of output gates, then
\[
	\text{Propagation Delay } (T_p) = a_1F_{in} + a_2F_{in}^2 + a_3F_{out}
\]
Transistor size of usually modifies for large fan-in gates.
\\\\
\noindent\textbf{Note: } Propagation delay for \(0 \to 1\) and \(1 \to 0\) may be different. We generally take max of both delays and consider it the propagation delay of the gate.

\bibliographystyle{unsrt}
\bibliography{main}
\end{document}